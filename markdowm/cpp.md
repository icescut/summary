# C++
## 语法
### 命名空间
为了解决多人合作命名冲突的问题。  
```C++
    //使用One空间
    using namespace::One;
    std::cout << a << std::endl;

    //指明使用Two空间的变量a
    std::cout << Two::a << std::endl;

    //指明后面的变量a使用Three空间的
    using Three::a;
    std::cout << a << std::endl;
```

## 数据类型
### 引用
* C语言只能使用按值传递参数，如果传递很大的数据项，复制数据将导致较长的执行时间。C++则新增了按引用传递，提高性能。  
* 引用是别名，声明时必须初始化，主要用于参数传递。  
* 对引用的修改就是对目标的修改。
* 引用一旦初始化就再不分开，不能赋其他值。
* 指针可以再赋值成指向别处的地址；引用必须初始化并不会再关联其他变量。
* void引用是不合法的
* 没有引用的数组
* 可以有指针变量的引用
* 没有的引用的指针和引用的引用
* 传递引用与传递指针效果一样，但传递引用更清晰
* 引用作为参数除了提高性能外还能解决需要多返回值的问题  
* 引用作为函数返回值，不生成副本，提高效率。return的值必须是外部变量。  
```C++
int n;
int& rn = n;    //必须初始化，&n == &rn

//可以有指针变量的引用
int *a = NULL;
int* &ra = a;

```

## 函数
获取参数或输入数据流，处理之后输出返回值或输出数据流。  
函数需要建立栈内存环境，进行参数传递，并产生程序执行转移。  
### 默认参数
C语言没有办法为函数指定默认参数，但c++可以在调用函数的时候不指定全部参数，为不指定的参数提供默认值。  
默认参数从右到左逐渐定义。调用时向左匹配参数。

```c++
int add(int x = 5, int y = 6, int z = 3);
//int add2(int x = 5, int y, int z = 3); 错误，默认参数从右到左定义
int main() {
    add();      //三个参数都使用默认值
    add(1,5);   //最后一个参数都使用默认值，从右往左匹配默认
    add(1,2,3)  //不使用默认参数
}
```

### 函数重载
定义：两个以上的函数，取相同的函数名，但是形参个数或者类型不同，编译器根据实参与形参的匹配确定使用哪个函数。
只有返回类型不同不能成为重载。有时用默认参数可以代替重载。重载与默认参数一起使用，可能产生二义性。    
C语言中，每个函数必须有唯一名字。但如果函数做的事情一样，只是参数不同，也不能取同一个名字。  

1. 严格匹配  
2. 通过转换能得到唯一匹配  

C头文件的规范： 
```C
#ifndef _FUNC_
#define _FUNC_

#ifdef __cplusplus
extern "C"{
#endif

void func();
#ifdef __cplusplus
}
#endif
#endif
```
为什么这样定义？与函数重载有关。如果用C编译的话，foo函数在符号表中的名字为foo，如果用c++编译，foo函数在符号表中的名字为Z3fooci，与参数、返回值有关了。如果不这样定义，C++程序是调用不了C的函数的。  


### 内联函数
产生的原因：  
1. 内联函数是为了避免宏定义的一些不可避免的问题并且能够提高效率（相对于普通函数）。  
2. 函数需要建立栈内存环境，进行参数传递，并产生程序执行转移。  

编译器看到inline函数的时候，为该函数创建一段代码，在后面每次碰到该函数都用这段代码代替。  
只在声明时加inline即可。  
不能包含复杂的控制语句，如switch和while，不能有递归。如果有，则编译器将其视为普通函数。  
内联函数适合1到5行的函数。  
宏定义可以代替小函数的定义，但是有缺陷，不检查参数类型。  

```C++

#define MAX(a,b) ((a) > (b) ? (a) : (b))
//在这里写一次inline即可
inline int max(int a, int b);

int main(){
    int a = 55, b = 4;
    int c = max(a++,b);
    //结果是55，正确
    cout << c << endl;
    //实际是((a++) > (b) ? (a++) : (b))
    int d = MAX(a++, b);
    //结果是57，不合预期
    cout << d << endl;
    return 0;
}

int max(int a, int b) {
    return a > b ? a : b;
}
```


